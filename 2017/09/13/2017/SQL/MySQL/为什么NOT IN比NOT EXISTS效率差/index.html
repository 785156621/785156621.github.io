<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 为什么NOT IN比NOT EXISTS效率差 · Hexo</title><meta name="description" content="为什么NOT IN比NOT EXISTS效率差 - gd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/3774381537" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/785156621" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">为什么NOT IN比NOT EXISTS效率差</h1><div class="post-info">2017年9月13日</div><div class="post-content"><h4 id="为什么NOT-IN效率差"><a href="#为什么NOT-IN效率差" class="headerlink" title="为什么NOT IN效率差"></a>为什么NOT IN效率差</h4><p>两个SQL, 用NOT IN和NOT EXISTS两种不同写法,效率差别很大. 下面两种不同的写法，第一种跑了几个小时也没出结果，第二种几分钟就跑完了</p>
<p>select id from r where r.id not in (select id from tbl);<br>select id from r where not exists (select id from tbl where id = r.id);</p>
<p>早就听说过NOT IN效率差,今天才第一次认识到这个问题的本质 (以下以PostgreSQL来说明）</p>
<h4 id="NOT-IN和NOT-EXISTS执行计划是不一样的"><a href="#NOT-IN和NOT-EXISTS执行计划是不一样的" class="headerlink" title="NOT IN和NOT EXISTS执行计划是不一样的"></a>NOT IN和NOT EXISTS执行计划是不一样的</h4><p><strong>NOT IN</strong></p>
<p>postgres=# explain select id from r where r.id not in (select id from tbl);<br>                               QUERY PLAN<br>-------------------------------------------------------------------------<br> Seq Scan on r  (cost=0.00..1905433091.42 rows=194644 width=7)<br>   Filter: (NOT (SubPlan 1))<br>   SubPlan 1<br>     ->  Materialize  (cost=0.00..8850.78 rows=375385 width=7)<br>           ->  Seq Scan on tbl  (cost=0.00..5506.85 rows=375385 width=7)<br>(5 rows)</p>
<p><strong>NOT EXISTS</strong></p>
<p>postgres=# explain select id from r where not exists (select id from tbl where id = r.id);<br>                              QUERY PLAN<br>-----------------------------------------------------------------------<br> Hash Anti Join  (cost=11666.16..40782.08 rows=13902 width=7)<br>   Hash Cond: ((r.id)::text = (tbl.id)::text)<br>   ->  Seq Scan on r  (cost=0.00..20668.87 rows=389287 width=7)<br>   ->  Hash  (cost=5506.85..5506.85 rows=375385 width=7)<br>         ->  Seq Scan on tbl  (cost=0.00..5506.85 rows=375385 width=7)<br>(5 rows)</p>
<p>我们看到, NOT EXISTS会被重写成Hash Anti Join, 而NOT IN不会,由于子查询中的结果集比较大, 产生了Materialize Hash join, 把二个表按照join key放入hash table, 然后遍历第一个表,在hash table中查找到第一个表的join key, 如果找到, 返回一条结果 Anti Join, 对于第一个表里的记录,当在第二张表没有发现与之匹配记录时，才会返回记录 与Anti Join类似但有相反意义的是Semi Join, 即在两表关联时,只返回第二个表第一次匹配的记录;Anti Join可以用于生成in select的计划</p>
<h4 id="Hash-Anti-Join更高效"><a href="#Hash-Anti-Join更高效" class="headerlink" title="Hash Anti Join更高效"></a>Hash Anti Join更高效</h4><p>以上两个执行计划, 后面的要比前面的更高效. 尤其是当子查询中的结果集比较大时, 需要产生Materialize, NOT IN效率恶化得更明显． 为什么这两个SQL生成计划是不一样的呢? 为什么不为NOT IN生成更优的计划, 就像NOT EXISTS一样? 实际上, 问题在于, 这两个SQL实际上有不同的语义.</p>
<h4 id="NOT-IN比较特殊的地方-在于NULL值的处理"><a href="#NOT-IN比较特殊的地方-在于NULL值的处理" class="headerlink" title="NOT IN比较特殊的地方,在于NULL值的处理"></a>NOT IN比较特殊的地方,在于NULL值的处理</h4><p>create table  ta ( no int, str varchar(20));<br>create table  tb (no int, str varchar(20));<br>insert into  ta (no, str) values (1, ‘a’), (2, ‘b’), (3, ‘c’), (4, ‘d’);<br>insert into tb(no, str) values (1, ‘a’), (2, ‘b’), (3, ‘c’), (4, NULL);</p>
<p>下面的两个SQL是不等价的</p>
<p>select no, str from ta where str not in (select str from tb);<br>select no, str from ta where not exists (select str from tb where str = ta.str);</p>
<p>not in查询结果:</p>
<p>postgres=# select no, str from ta where str not in (select str from tb);<br> no | str<br>—-+—–<br>(0 rows)</p>
<p>not exists查询结果:</p>
<p>postgres=# select no, str from ta where not exists (select str from tb where str = ta.str);<br> no | str<br>—-+—–<br>  4 | d<br>(1 row)</p>
<p>或许和我们期望的结果不太一样 如果去掉子查询中的NULL, NOT IN和NOT EXISTS的结果就是相同的</p>
<p>postgres=# select no, str from ta where str not in (select str from tb where str is not null);<br> no | str<br>—-+—–<br>  4 | d<br>(1 row)</p>
<p>如果IN list中有一个值为空, 那么整个查询的结果集就是空的 SQL标准规定, NULL的任何运算(除了类似IS NULL这种)都返回NULL 对于下面的SQL, 返回的结果集是空</p>
<p>select no, str from ta where str not in ( ‘a’, NULL); – empty resultset</p>
<p>‘d’ not in (‘a’, NULL)返回值是NULL(不是True, 也不是False)</p>
<p>select ‘d’ not in (‘a’, NULL);  – NULL</p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>由上面可以看出, NOT EXISTS比NOT IN效率更高, 是因为生成了更高效的执行计划 因为SQL标准对NULL的定义, NOT IN无法像NOT EXISTS那样生成更为高效的Hash Anti Join的计划 所以，以后应该尽量避免用NOT IN这种写法, 虽然想不通NOT IN对NULL处理的这种语义在现实中有什么意义^^   原文链接：<a href="http://blog.chinaunix.net/uid-29128384-id-4417450.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-29128384-id-4417450.html</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/18/2017/PHP/php获取时间是星期几/" class="prev">上一篇</a><a href="/2017/09/13/2017/SQL/PostgreSQL/PostgreSQL快速随机取出记录/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">gd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>