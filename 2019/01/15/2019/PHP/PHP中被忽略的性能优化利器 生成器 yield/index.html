<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PHP中被忽略的性能优化利器：生成器 yield · gdmizi</title><meta name="description" content="PHP中被忽略的性能优化利器：生成器 yield - gd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="gdmizi"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/3774381537" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/785156621" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">PHP中被忽略的性能优化利器：生成器 yield</h1><div class="post-info">2019年1月15日</div><div class="post-content"><p>如果是做Python或者其他语言的小伙伴，对于生成器应该不陌生。但很多PHP开发者或许都不知道生成器这个功能，可能是因为生成器是PHP 5.5.0才引入的功能，也可以是生成器作用不是很明显。但是，生成器功能的确非常有用。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>直接讲概念估计你听完还是一头雾水，所以我们先来说说优点，也许能勾起你的兴趣。那么生成器有哪些优点，如下：</p>
<p>生成器会对PHP应用的性能有非常大的影响<br>PHP代码运行时节省大量的内存<br>比较适合计算大量的数据<br>那么，这些神奇的功能究竟是如何做到的？我们先来举个例子。</p>
<h1 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h1><p>首先，放下生成器概念的包袱，来看一个简单的PHP函数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRange</span><span class="params">($number)</span></span>&#123;</span><br><span class="line">    $data = [];</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$number;$i++)&#123;</span><br><span class="line">        $data[] = time();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单：</p>
<p>我们创建一个函数。<br>函数内包含一个for循环，我们循环的把当前时间放到$data里面<br>for循环执行完毕，把$data返回出去。<br>下面没完，我们继续。我们再写一个函数，把这个函数的返回值循环打印出来：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$result = createRange(<span class="number">10</span>); <span class="comment">// 这里调用上面我们创建的函数</span></span><br><span class="line"><span class="keyword">foreach</span>($result <span class="keyword">as</span> $value)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//这里停顿1秒，我们后续有用</span></span><br><span class="line">    <span class="keyword">echo</span> $value.<span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在浏览器里面看一下运行结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/1264945/201712/1264945-20171208233256937-1531241860.png" alt=""></p>
<p>这里非常完美，没有任何问题。（当然sleep(1)效果你们看不出来）</p>
<h1 id="思考一个问题"><a href="#思考一个问题" class="headerlink" title="思考一个问题"></a>思考一个问题</h1><p>我们注意到，在调用函数createRange的时候给$number的传值是10，一个很小的数字。假设，现在传递一个值10000000（1000万）。</p>
<p>那么，在函数createRange里面，for循环就需要执行1000万次。且有1000万个值被放到$data里面，而$data数组在是被放在内存内。所以，在调用函数时候会占用大量内存。</p>
<p>这里，生成器就可以大显身手了。</p>
<h1 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h1><p>我们直接修改代码，你们注意观察：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRange</span><span class="params">($number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$number;$i++)&#123;</span><br><span class="line">        <span class="keyword">yield</span> time();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下这段和刚刚很像的代码，我们删除了数组$data，而且也没有返回任何内容，而是在time()之前使用了一个关键字yield</p>
<h1 id="使用生成器"><a href="#使用生成器" class="headerlink" title="使用生成器"></a>使用生成器</h1><p>我们再运行一下第二段代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$result = createRange(<span class="number">10</span>); <span class="comment">// 这里调用上面我们创建的函数</span></span><br><span class="line"><span class="keyword">foreach</span>($result <span class="keyword">as</span> $value)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">echo</span> $value.<span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images2017.cnblogs.com/blog/1264945/201712/1264945-20171208233632390-935214245.png" alt=""></p>
<p>我们奇迹般的发现了，输出的值和第一次没有使用生成器的不一样。这里的值（时间戳）中间间隔了1秒。</p>
<p>这里的间隔一秒其实就是sleep(1)造成的后果。但是为什么第一次没有间隔？那是因为：</p>
<p>未使用生成器时：createRange函数内的for循环结果被很快放到$data中，并且立即返回。所以，foreach循环的是一个固定的数组。<br>使用生成器时：createRange的值不是一次性快速生成，而是依赖于foreach循环。foreach循环一次，for执行一次。<br>到这里，你应该对生成器有点儿头绪。</p>
<h1 id="深入理解生成器"><a href="#深入理解生成器" class="headerlink" title="深入理解生成器"></a>深入理解生成器</h1><h2 id="代码剖析"><a href="#代码剖析" class="headerlink" title="代码剖析"></a>代码剖析</h2><p>下面我们来对于刚刚的代码进行剖析。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRange</span><span class="params">($number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$number;$i++)&#123;</span><br><span class="line">        <span class="keyword">yield</span> time();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$result = createRange(<span class="number">10</span>); <span class="comment">// 这里调用上面我们创建的函数</span></span><br><span class="line"><span class="keyword">foreach</span>($result <span class="keyword">as</span> $value)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">echo</span> $value.<span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来还原一下代码执行过程。</p>
<p>首先调用createRange函数，传入参数10，但是for值执行了一次然后停止了，并且告诉foreach第一次循环可以用的值。<br>foreach开始对$result循环，进来首先sleep(1)，然后开始使用for给的一个值执行输出。<br>foreach准备第二次循环，开始第二次循环之前，它向for循环又请求了一次。<br>for循环于是又执行了一次，将生成的时间戳告诉foreach.<br>foreach拿到第二个值，并且输出。由于foreach中sleep(1)，所以，for循环延迟了1秒生成当前时间<br>所以，整个代码执行中，始终只有一个记录值参与循环，内存中也只有一条信息。</p>
<p>无论开始传入的$number有多大，由于并不会立即生成所有结果集，所以内存始终是一条循环的值。</p>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>到这里，你应该已经大概理解什么是生成器了。下面我们来说下生成器原理。</p>
<p>首先明确一个概念：生成器yield关键字不是返回值，他的专业术语叫产出值，只是生成一个值</p>
<p>那么代码中foreach循环的是什么？其实是PHP在使用生成器的时候，会返回一个Generator类的对象。foreach可以对该对象进行迭代，每一次迭代，PHP会通过Generator实例计算出下一次需要迭代的值。这样foreach就知道下一次需要迭代的值了。</p>
<p>而且，在运行中for循环执行后，会立即停止。等待foreach下次循环时候再次和for索要下次的值的时候，for循环才会再执行一次，然后立即再次停止。直到不满足条件不执行结束。</p>
<h1 id="实际开发应用"><a href="#实际开发应用" class="headerlink" title="实际开发应用"></a>实际开发应用</h1><p>很多PHP开发者不了解生成器，其实主要是不了解应用领域。那么，生成器在实际开发中有哪些应用？</p>
<h2 id="读取超大文件"><a href="#读取超大文件" class="headerlink" title="读取超大文件"></a>读取超大文件</h2><p>PHP开发很多时候都要读取大文件，比如csv文件、text文件，或者一些日志文件。这些文件如果很大，比如5个G。这时，直接一次性把所有的内容读取到内存中计算不太现实。</p>
<p>这里生成器就可以派上用场啦。简单看个例子：读取text文件</p>
<p><img src="https://images2017.cnblogs.com/blog/1264945/201712/1264945-20171208235318968-125612710.png" alt=""></p>
<p>我们创建一个text文本文档，并在其中输入几行文字，示范读取。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readTxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment"># code...</span></span><br><span class="line">    $handle = fopen(<span class="string">"./test.txt"</span>, <span class="string">'rb'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (feof($handle)===<span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="comment"># code...</span></span><br><span class="line">        <span class="keyword">yield</span> fgets($handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (readTxt() <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">    <span class="comment"># code...</span></span><br><span class="line">    <span class="keyword">echo</span> $value.<span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images2017.cnblogs.com/blog/1264945/201712/1264945-20171208235527577-1441221196.png" alt=""></p>
<p>通过上图的输出结果我们可以看出代码完全正常。</p>
<p>但是，背后的代码执行规则却一点儿也不一样。使用生成器读取文件，第一次读取了第一行，第二次读取了第二行，以此类推，每次被加载到内存中的文字只有一行，大大的减小了内存的使用。</p>
<p>这样，即使读取上G的文本也不用担心，完全可以像读取很小文件一样编写代码。</p>
<p>本文转载自 <a href="https://segmentfault.com/a/1190000012334856" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012334856</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/01/17/2019/PHP/php 中文字符串替换/" class="prev">上一篇</a><a href="/2017/12/13/2017/PHP/Laravel/局域网内访问Homestead环境/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">gd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>